--
1)
Сделать запрос для получения атрибутов из указанных таблиц, применив фильтры по указанным условиям:
Таблицы: Н_ЛЮДИ, Н_ВЕДОМОСТИ.
Вывести атрибуты: Н_ЛЮДИ.ИМЯ, Н_ВЕДОМОСТИ.ДАТА.
Фильтры (AND):
a) Н_ЛЮДИ.ИД = 142095.
b) Н_ВЕДОМОСТИ.ИД = 1490007.
Вид соединения: LEFT JOIN.
--

SELECT Н_ЛЮДИ.ИМЯ, Н_ВЕДОМОСТИ.ДАТА
FROM Н_ЛЮДИ
LEFT JOIN Н_ВЕДОМОСТИ ON Н_ЛЮДИ.ИД = Н_ВЕДОМОСТИ.ЧЛВК_ИД
WHERE Н_ЛЮДИ.ИД = 142095 AND Н_ВЕДОМОСТИ.ИД = 1490007;

--
2)
Сделать запрос для получения атрибутов из указанных таблиц, применив фильтры по указанным условиям:
Таблицы: Н_ЛЮДИ, Н_ВЕДОМОСТИ, Н_СЕССИЯ.
Вывести атрибуты: Н_ЛЮДИ.ФАМИЛИЯ, Н_ВЕДОМОСТИ.ЧЛВК_ИД, Н_СЕССИЯ.УЧГОД.
Фильтры (AND):
a) Н_ЛЮДИ.ФАМИЛИЯ < Петров.
b) Н_ВЕДОМОСТИ.ИД > 39921.
c) Н_СЕССИЯ.ДАТА > 2012-01-25.
Вид соединения: INNER JOIN.
--

SELECT Н_ЛЮДИ.ФАМИЛИЯ, Н_ВЕДОМОСТИ.ЧЛВК_ИД, Н_СЕССИЯ.УЧГОД
FROM Н_ЛЮДИ
INNER JOIN Н_ВЕДОМОСТИ ON Н_ЛЮДИ.ИД = Н_ВЕДОМОСТИ.ЧЛВК_ИД
INNER JOIN Н_СЕССИЯ ON Н_ВЕДОМОСТИ.СЭС_ИД = Н_СЕССИЯ.СЭС_ИД
WHERE Н_ЛЮДИ.ФАМИЛИЯ < 'Петров'
AND Н_ВЕДОМОСТИ.ИД > 39921
AND Н_СЕССИЯ.ДАТА > '2012-01-25';

--
3)
Вывести число студентов вечерней формы обучения, которые не имеет отчества.
Ответ должен содержать только одно число.
--

SELECT COUNT(*)
FROM Н_ЛЮДИ
JOIN Н_ВЕДОМОСТИ ON Н_ЛЮДИ.ИД = Н_ВЕДОМОСТИ.ЧЛВК_ИД
WHERE Н_ЛЮДИ.ОТЧЕСТВО IS NULL AND Н_ВЕДОМОСТИ.ТВ_ИД = 2;

--
6) 
Получить список студентов, зачисленных ровно первого сентября 2012 года на первый курс очной формы обучения (специальность: 230101). В результат включить:
номер группы;
номер, фамилию, имя и отчество студента;
номер и состояние пункта приказа;
Для реализации использовать соединение таблиц.
--

SELECT "ВНЕШ_УЧЕНИКИ"."ГРУППА",
       "ВНЕШ_УЧЕНИКИ"."ИД",
       "Н_ЛЮДИ"."ФАМИЛИЯ",
       "Н_ЛЮДИ"."ИМЯ",
       "Н_ЛЮДИ"."ОТЧЕСТВО",
       "ВНЕШ_УЧЕНИКИ"."П_ПРКОК_ИД",
       "ВНЕШ_УЧЕНИКИ"."СОСТОЯНИЕ"
FROM "Н_УЧЕНИКИ" "ВНЕШ_УЧЕНИКИ"
  JOIN "Н_ЛЮДИ" ON "Н_ЛЮДИ"."ИД" = "ВНЕШ_УЧЕНИКИ"."ЧЛВК_ИД"
  JOIN "Н_ПЛАНЫ" ON "ВНЕШ_УЧЕНИКИ"."ПЛАН_ИД" = "Н_ПЛАНЫ"."ИД"
  JOIN "Н_ФОРМЫ_ОБУЧЕНИЯ" ON "Н_ПЛАНЫ"."ФО_ИД" = "Н_ФОРМЫ_ОБУЧЕНИЯ"."ИД"
    AND "Н_ФОРМЫ_ОБУЧЕНИЯ"."НАИМЕНОВАНИЕ" = 'Очная'

  JOIN "Н_НАПРАВЛЕНИЯ_СПЕЦИАЛ" ON "Н_ПЛАНЫ"."НАПС_ИД" = "Н_НАПРАВЛЕНИЯ_СПЕЦИАЛ"."ИД"
  JOIN "Н_НАПР_СПЕЦ" ON "Н_НАПР_СПЕЦ"."ИД" = "Н_НАПРАВЛЕНИЯ_СПЕЦИАЛ"."НС_ИД"
    AND "Н_НАПР_СПЕЦ"."НАИМЕНОВАНИЕ" = 'Программная инженерия'

WHERE "ВНЕШ_УЧЕНИКИ"."ПРИЗНАК" = 'зачислен'
  AND "ВНЕШ_УЧЕНИКИ"."СОСТОЯНИЕ" = 'утвержден'
  AND DATE("ВНЕШ_УЧЕНИКИ"."НАЧАЛО") = '2012-09-01';


--
7) 
Сформировать запрос для получения числа на ФКТИУ отличников
--

SELECT COUNT(DISTINCT "Н_ВЕДОМОСТИ"."ЧЛВК_ИД") AS "Количество отличников"
FROM "Н_ВЕДОМОСТИ"
JOIN "Н_ОЦЕНКИ" ON "Н_ВЕДОМОСТИ"."ОЦЕНКА" = "Н_ОЦЕНКИ"."КОД"
JOIN "Н_УЧЕНИКИ" ON "Н_ВЕДОМОСТИ"."ЧЛВК_ИД" = "Н_УЧЕНИКИ"."ЧЛВК_ИД"
JOIN "Н_ПЛАНЫ" ON "Н_УЧЕНИКИ"."ПЛАН_ИД" = "Н_ПЛАНЫ"."ИД"
JOIN "Н_ОТДЕЛЫ" ON "Н_ПЛАНЫ"."ОТД_ИД" = "Н_ОТДЕЛЫ"."ИД"
WHERE "Н_ОТДЕЛЫ"."КОРОТКОЕ_ИМЯ" = 'КТиУ' AND "Н_ОЦЕНКИ"."СОРТ" >= 5;

--
доп.1 - сделать, чтобы запрос выводил отличников в алфавитном порядке
--

SELECT "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
FROM "Н_ВЕДОМОСТИ"
JOIN "Н_ОЦЕНКИ" ON "Н_ВЕДОМОСТИ"."ОЦЕНКА" = "Н_ОЦЕНКИ"."КОД"
JOIN "Н_УЧЕНИКИ" ON "Н_ВЕДОМОСТИ"."ЧЛВК_ИД" = "Н_УЧЕНИКИ"."ЧЛВК_ИД"
JOIN "Н_ПЛАНЫ" ON "Н_УЧЕНИКИ"."ПЛАН_ИД" = "Н_ПЛАНЫ"."ИД"
JOIN "Н_ОТДЕЛЫ" ON "Н_ПЛАНЫ"."ОТД_ИД" = "Н_ОТДЕЛЫ"."ИД"
JOIN "Н_ЛЮДИ" ON "Н_УЧЕНИКИ"."ЧЛВК_ИД" = "Н_ЛЮДИ"."ИД"
WHERE "Н_ОТДЕЛЫ"."КОРОТКОЕ_ИМЯ" = 'КТиУ' AND "Н_ОЦЕНКИ"."СОРТ" >= 5
GROUP BY "Н_ЛЮДИ"."ИД", "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
ORDER BY "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО";

--
доп.2

вывести:
1) список студентов МУЖСКОГО ПОЛА и с фамилиями на буквы от К до С
2) которые сдавали сессию за последние 10 лет 
3) в аудиториях на 3 этаже (ограничить трёхзначными)
4) и сдали на хорошо

1) Н_ЛЮДИ, Н_УЧЕНИКИ
2) Н_СЕССИЯ
3) Н_СЕССИЯ имеет после Н_АУДИТОРИЯ. первая цифра - это этаж. брать только трёхзначные
4) Н_ВЕДОМОСТИ -> Н_ОЦЕНКИ
--

SELECT "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
FROM "Н_ВЕДОМОСТИ"
JOIN "Н_ОЦЕНКИ" ON "Н_ВЕДОМОСТИ"."ОЦЕНКА" = "Н_ОЦЕНКИ"."КОД"
JOIN "Н_УЧЕНИКИ" ON "Н_ВЕДОМОСТИ"."ЧЛВК_ИД" = "Н_УЧЕНИКИ"."ЧЛВК_ИД"
JOIN "Н_ЛЮДИ" ON "Н_УЧЕНИКИ"."ЧЛВК_ИД" = "Н_ЛЮДИ"."ИД"
JOIN "Н_СЕССИЯ" ON "Н_ВЕДОМОСТИ"."СЭС_ИД" = "Н_СЕССИЯ"."ИД"
WHERE "Н_ЛЮДИ"."ПОЛ" = 'М' AND
      "Н_ЛЮДИ"."ФАМИЛИЯ" >= 'К' AND "Н_ЛЮДИ"."ФАМИЛИЯ" < 'Т' AND
      "Н_СЕССИЯ"."ДАТА" >= CURRENT_DATE - INTERVAL '10 years' AND
      "Н_СЕССИЯ"."АУДИТОРИЯ" >= '300' AND "Н_СЕССИЯ"."АУДИТОРИЯ" < '400' AND
      "Н_ОЦЕНКИ"."СОРТ" >= 4
GROUP BY "Н_ЛЮДИ"."ИД", "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
ORDER BY "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО";

--
вопрос про подзапросы:
--

Подзапросы могут быть разделены на следующие виды:

    Скалярные подзапросы: Эти подзапросы возвращают только одно значение (одну строку и один столбец). Они часто используются в операторах сравнения, в операторе SELECT или в выражениях. Например:

SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

    Подзапросы в списках: Эти подзапросы возвращают один или несколько столбцов и могут быть использованы с операторами IN, ANY или ALL. Например:

SELECT name, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name LIKE '%IT%');

    Коррелированные подзапросы: Это подзапросы, которые зависят от внешнего запроса и выполняются для каждой строки внешнего запроса. Они могут быть использованы для выполнения более сложных операций, таких как иерархические запросы или вычисление ранга. Например:

SELECT e1.name, e1.salary
FROM employees e1
WHERE e1.salary > (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = e1.department_id);

    Подзапросы во FROM-клаузе: Иногда подзапросы могут быть использованы во FROM-клаузе для обработки результатов других запросов или создания временных таблиц. Например:

SELECT department_id, AVG(salary) AS avg_salary
FROM (SELECT department_id, salary FROM employees) AS subquery
GROUP BY department_id;

    Подзапросы в операторах EXISTS и NOT EXISTS: Эти подзапросы используются для проверки наличия или отсутствия данных, соответствующих условию, заданному внутри подзапроса. Например:

SELECT name, department_id
FROM employees
WHERE EXISTS (SELECT 1 FROM departments WHERE id = employees.department_id AND name = 'IT');


